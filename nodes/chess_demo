#! /usr/bin/env python3

import math

import time
import rospy
from std_msgs.msg import String, UInt8, UInt8MultiArray, Float32, Float32MultiArray
from open_manipulator_msgs.srv import *


offset_x = 0.012
offset_z = 0.0595 + 0.017
l1 = 0.128
l2 = 0.024
l1c = 0.13023 # combined l1 - l2 length
l3 = 0.124
l4 = 0.126

j1o = math.atan(l2/l1)
j2o = math.pi - ((math.pi/2.0) - j1o)

home = [-0.002, -1.049, 0.357, 0.706]
up = [0.12]
down = [0.05]
a8=[0.07, 0.10]
d6=[0.12, -0.013]
d4=[0.175, -0.013]

class OpenManipulatorChessDemo:
    def __init__(self):
        pass

                        
    def main(self):                                                              
        rospy.init_node('open_manipulator_chess_demo')
        self.nodeName = rospy.get_name()
        rospy.loginfo("{0} started".format(self.nodeName))

        self.set_actuator_state(True)

        while not rospy.is_shutdown():
            '''
            self.gripper("open")
            time.sleep(1)
            angles = self.inverse_kinematics(self.A8("up"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            angles = self.inverse_kinematics(self.D6("up"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            angles = self.inverse_kinematics(self.D6("down"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            self.gripper("close")
            time.sleep(1)
            angles = self.inverse_kinematics(self.D6("up"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            angles = self.inverse_kinematics(self.D4("up"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            angles = self.inverse_kinematics(self.D4("down"))
            self.set_joint_client(angles,1)
            time.sleep(1)
            self.gripper("open")
            time.sleep(1)
            angles = self.inverse_kinematics(self.D4("up"))
            self.set_joint_client(angles,1)
            '''
            #self.chess_move(d6, d4)
            self.move_to(d6)
            break


    def inverse_kinematics(self, coords):
        angles = [0,0,0,0]

        j0 = math.atan(coords[1]/(coords[0] - offset_x))

        x = coords[0] - offset_x# - l4 * math.cos(j0)
        y = coords[1]# - l4 * math.sin(j0)
        z = coords[2] - offset_z + l4

        # recalculate x
        x = math.sqrt(y*y + x*x)

        c = math.sqrt(x*x + z*z)
        alpha = math.asin(z/c)
        beta = (math.pi / 2.0) - alpha

        gamma = math.acos((l1c*l1c + c*c - l3*l3)/(2*c*l1c))

        j1 = (math.pi / 2.0) - alpha - gamma - j1o
        j2 = math.acos((l1c*l1c + l3*l3 - c*c)/(2*l1c*l3)) - j2o
        
        delta = math.pi - gamma - j2 - j2o

        j3 = math.pi - (beta + delta)


        angles[0] = j0
        angles[1] = j1
        angles[2] = -j2
        angles[3] = j3
        return angles

    def set_joint_client(self, angles, time):
        service_name = '/open_manipulator/goal_joint_space_path'

        rospy.wait_for_service(service_name,1)
        try:
            set_joint_angles = rospy.ServiceProxy(service_name, SetJointPosition)
            arg = SetJointPositionRequest()
            arg.joint_position.joint_name = ["joint1", "joint2", "joint3", "joint4"]
            arg.joint_position.position = angles
            arg.path_time = time
            resp1 = set_joint_angles(arg)
            print('Service done!')
            return resp1
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)
            return False

    def set_actuator_state(self, state):
        service_name = '/open_manipulator/set_actuator_state'

        rospy.wait_for_service(service_name,1)

        try:
            set_state = rospy.ServiceProxy(service_name, SetActuatorState)

            arg = SetActuatorStateRequest()
            arg.set_actuator_state = state
            resp1 = set_state(arg)
            print('Service done!')
            return resp1
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)
            return False

    def set_gripper_client(self, gripper, time):
        service_name = '/open_manipulator/goal_tool_control'

        rospy.wait_for_service(service_name,1)

        try:
            set_joint_angles = rospy.ServiceProxy(service_name, SetJointPosition)

            arg = SetJointPositionRequest()
            arg.joint_position.joint_name = ["gripper"]
            arg.joint_position.position = [gripper]
            arg.path_time = time
            resp1 = set_joint_angles(arg)
            print('Service done!')
            return resp1
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)
            return False

    def gripper(self, state):
        if state.lower() == "open":
            self.set_gripper_client(0.01,0.5)
        elif state.lower() == "close":
            self.set_gripper_client(-0.01,0.5)
        else:
            print("invalid gripper state")

    def chess_move(self, start, goal):
        angles = self.inverse_kinematics(start + up)
        self.set_joint_client(angles,1)
        time.sleep(1)
        angles = self.inverse_kinematics(start + down)
        self.set_joint_client(angles,1)
        time.sleep(1)
        self.gripper("close")
        time.sleep(1)
        angles = self.inverse_kinematics(start + up)
        self.set_joint_client(angles,1)
        time.sleep(1)
        angles = self.inverse_kinematics(goal + up)
        self.set_joint_client(angles,1)
        time.sleep(1)
        angles = self.inverse_kinematics(goal + down)
        self.set_joint_client(angles,1)
        time.sleep(1)
        self.gripper("open")
        time.sleep(1)
        angles = self.inverse_kinematics(goal + up)
        self.set_joint_client(angles,1)
        time.sleep(1)
        self.set_joint_client(home,1)
        time.sleep(1)

    def move_to(self, start):
        angles = self.inverse_kinematics(start + down)
        self.set_joint_client(angles,1)
        time.sleep(1)



    def A8(self, z):
        x_pos = 0.07
        y_pos = 0.10
        if z.lower()=="up":
            z_pos = 0.12
        elif z.lower()=="down":
            z_pos = 0.06
        else:
            print("Invalid z")

        return [x_pos,y_pos,z_pos]

    def D6(self, z):
        x_pos = 0.12
        y_pos = -0.013
        if z.lower()=="up":
            z_pos = 0.12
        elif z.lower()=="down":
            z_pos = 0.05
        else:
            print("Invalid z")

        return [x_pos,y_pos,z_pos]

    def D4(self, z):
        x_pos = 0.175
        y_pos = -0.013
        if z.lower()=="up":
            z_pos = 0.12
        elif z.lower()=="down":
            z_pos = 0.05
        else:
            print("Invalid z")

        return [x_pos,y_pos,z_pos]


if __name__ == '__main__':
    try:
        node = OpenManipulatorChessDemo()
        node.main()
    except rospy.ROSInterruptException:
        pass